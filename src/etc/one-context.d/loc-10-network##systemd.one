#!/usr/bin/env bash

# -------------------------------------------------------------------------- #
# Copyright 2010-2020, OpenNebula Systems                                    #
#                                                                            #
# Licensed under the Apache License, Version 2.0 (the "License"); you may    #
# not use this file except in compliance with the License. You may obtain    #
# a copy of the License at                                                   #
#                                                                            #
# http://www.apache.org/licenses/LICENSE-2.0                                 #
#                                                                            #
# Unless required by applicable law or agreed to in writing, software        #
# distributed under the License is distributed on an "AS IS" BASIS,          #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
# See the License for the specific language governing permissions and        #
# limitations under the License.                                             #
#--------------------------------------------------------------------------- #

COMMAND=${1}

#*******************************************************************************
# Function definition
#*******************************************************************************
# Gets the value of a context variable according to an iface
# Input: Name of a context var (e.g. 'IP', 'MASK'...)
# Output: Context var content
get_context_iface_var() {
    local var_name="${upcase_dev}_${1}"
    #local value=$(eval "echo \"\${$var_name}\"")
    local value=$(cat /var/run/one-context/context.sh.network | grep -E "${var_name}=" | awk -F "'" '{print $2}') #DEBUG

    echo ${value}
}

# Gets the real iface name according to the MAC address (e.g. context: ETH0 -> system: ens3)
# Input:
#  - $1: A list of ifaces and theirs related MAC address
#  - $2: A MAC address to match an iface name
# Output: The name of the first iface matching
get_dev() {
    local list="${1}"
    local mac="${2}"

    echo "${list}" | grep "${mac}" | cut -d' ' -f1 | tail -n1
}

# Gets the name of all the interfaces from ONE context
# Input: none
# Output: All the interfaces from ONE context
get_context_interfaces() {
    #env | grep -E "^ETH[0-9]+_MAC=" | sed 's/_.*$//' | sort
    cat /var/run/one-context/context.sh.network | grep -E "^ETH[0-9]+_MAC=" | sed 's/_.*$//' | sort #DEBUG
}

# Gets all the ifaces MAC address
# Input: none
# Output: $mac_addresses
get_interface_mac() {
    local mac_addresses=$(ip link show | awk '/^[0-9]+: [A-Za-z0-9@]+:/ { device=$2; gsub(/:/, "",device); split(device,dev,"@")} /link\/ether/ { print dev[1]  " " $2 }')

    echo "${mac_addresses}"
}

# Ensure 'systemd-networkd' daemon is ready to use
# Input: none
# Output: none
is_systemd_networkd() {
    systemctl list-units --full -all | grep -Fq 'systemd-networkd.service'

    if [[ $? == 0 ]] && [ -d /etc/systemd/network ]; then
        return 0
    else
        return 1
    fi
}

# Convert dotted decimal netmask to CIDR notation
# Input: Dotted decimal netmask
# Output: $nbits (CIDR netmask)
mask2cidr() {
    local mask="${1}"
    local nbits=0
    local IFS=.

    for dec in $mask ; do
        case $dec in
            255) let nbits+=8 ;;
            254) let nbits+=7 ; break ;;
            252) let nbits+=6 ; break ;;
            248) let nbits+=5 ; break ;;
            240) let nbits+=4 ; break ;;
            224) let nbits+=3 ; break ;;
            192) let nbits+=2 ; break ;;
            128) let nbits+=1 ; break ;;
            0);;
            *) echo "Error: ${dec} is not recognised"; exit 1
        esac
    done

    echo "${nbits}"
}

# Generate network file content
# Input: none
# Output: $iface_config_content
gen_iface_config() {
    context_mac=$(get_context_iface_var "MAC")
    iface_real_name=$(get_dev "${INTERFACES_MAC}" "${context_mac}")

    # Split the interface configuration by section
    ## Section: MATCH (mandatory)
    match_section="[Match]\nName=${iface_real_name}\n"

    ## Section: LINK (optionnal)
    mtu=$(get_context_iface_var "MTU")
    if [[ ! -z $mtu ]]; then
        link_section="\n[Link]\nMTUBytes=${mtu}\n"
    else
        link_section=''
    fi

    ## Section: NETWORK (mandatory)
    linklocaladdressing=$(get_context_iface_var "LINKLOCALADDRESSING") #Context var should be added!
    ipv4_addr=$(get_context_iface_var "IP")
    ipv4_netmask=$(get_context_iface_var "MASK")
    ipv4_cidr_netmask=$(mask2cidr "${ipv4_netmask}")
    ipv4_gateway=$(get_context_iface_var "GATEWAY")
    dns_servers=$(get_context_iface_var "DNS")
    domains=$(get_context_iface_var "DOMAINS") #Context var should be added!

    network_optionnals=''
    if [[ -n $ipv4_gateway ]]; then
        network_optionnals="Gateway=${ipv4_gateway}\n"
    fi

    for resolver in $dns_servers; do
        network_optionnals="${network_optionnals}DNS=${resolver}\n"
    done

    if [[ -n $domains ]]; then
        network_optionnals="${network_optionnals}Domains=${domains}\n"
    fi

    read -r -d '' network_section << EOT
\n[Network]
Description=Network configuration generated with one-contextd
LinkLocalAddressing=${linklocaladdressing:-no}
Address=${ipv4_addr}/${ipv4_cidr_netmask}
${network_optionnals}
EOT

    ## Section: ROUTE (optionnal)
    route_section=''
    routes=$(get_context_iface_var "ROUTES") #Context var should be added!
    #routes="[dest=10.0.0.0/8, gw=10.0.0.1], [dest=172.16.0.0/12, gw=10.0.0.1], [dest=192.168.0.0/16, gw=10.0.0.1], [gw=10.0.0.1, metric=1]" #DEBUG

    # Routes are delimited by '[]'
    IFS='[]' read -r -a routes2array <<< "${routes}"
    for route in "${routes2array[@]}"; do
        route_info=''

        # Valide route must contain a gateway
        if [[ $route =~ [gw=.*] ]]; then

            # Parse route configuration
            for option in $route; do
                    if [[ $option =~ dest=[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\/[0-9]{1,2} ]]; then #TODO: regex enhancement
                        local dest=$(echo "${option}" | awk -F'[=,]' '{print $2}')
                        route_info="${route_info}Destination=${dest}\n"
                    elif [[ $option =~ gw=[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3} ]]; then #TODO: regex enhancement
                        local gw=$(echo "${option}" | awk -F'[=,]' '{print $2}')
                        route_info="${route_info}Gateway=${gw}\n"
                    elif [[ $option =~ metric=[0-9]+ ]]; then
                        local metric=$(echo "${option}" | awk -F'[=,]' '{print $2}')
                        route_info="${route_info}Metric=${metric}"
                    else
                        echo "Error: ${option} is not recognised"
                    fi
            done

            if [[ -n $route_info ]]; then
                route_section="${route_section}\n[Route]\n${route_info}"
            fi
        fi
    done

    iface_config_content="${match_section}${link_section}${network_section}${route_section}"
}

# Write network configuration in systemd file
# Input: none
# Output: '/etc/systemd/network/${iface}.network' file
write_iface_config() {
    local iface_path="/etc/systemd/network/${iface_real_name}.network"

    echo -e "---\nfile: '${iface_path}'\n${iface_config_content}" #DEBUG
    echo -e "${iface_config_content}" > "${iface_path}"
}

# Main function to configure the VM network using 'systemd-networkd' daemon
# Input: none
# Output: none
configure_network() {
    if [ is_systemd_networkd ]; then
        CONTEXT_INTERFACES=$(get_context_interfaces)
        INTERFACES_MAC=$(get_interface_mac)

        for interface in $CONTEXT_INTERFACES; do
            upcase_dev="${interface}"

            gen_iface_config
            write_iface_config
        done

        systemctl restart systemd-networkd.service
        systemctl enable systemd-networkd.service

        if [[ $? != 0 ]]; then
            exit 1
        fi

    else
        exit 1
    fi

    exit 0
}

#*******************************************************************************
# Main program
#*******************************************************************************
configure_network
